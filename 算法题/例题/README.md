## P1887 乘积最大3

请你找出M个和为N的正整数，他们的乘积要尽可能的大。

输出字典序最小的一种方案。

输入格式：一行，两个正整数 N,M

输出格式：M个和为N的，乘积尽可能的大的正整数

* :alien:**思路：
  当一个数n被分为m份时，当每份数量相等，这m个数的乘积最大，因而我们只需要使这m个数都相等就行了，所以有了q=n/m。所以每个数要尽量的接近q，整形n/m结果为整数向下取整，所以这两个数只有两种n/m和n/m +1**
## P1548 棋盘问题
设有一个N×M方格的棋盘求出该棋盘中包含有多少个正方形、多少个长方形（不包括正方形）

输入格式：N,M

输出格式：正方形的个数与长方形的个数
* :sunglasses:**思路：
先推出正方形的个数，接着推出长方形和正方形的总数，长方形的个数就是总数减去正方形的个数**
* 长方形和正方形的总数：（1+2+...+N）（1+2+...+M） *（奥数公式）*
## P2670 扫雷游戏 && P1320 压缩技术（续集版）
* :grin:**思路：两题都是通过先输入字符串或者字符串数组，然后在输入字符串的基础上进行运算**
## P1146 硬币翻转
在桌面上有一排硬币，共NN枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，规则是每次可翻转任意N-1N−1枚硬币（正面向上的被翻转为反面向上，反之亦然）。求一个最短的操作序列（将每次翻转N-1枚硬币成为一次操作）。

输入格式
一个自然数N（N为不大于100100的偶数）。出格式
第一行包含一个整数S，表示最少需要的操作次数。接下来的S行每行分别表示每次操作后桌上硬币的状态（一行包含N个整数（0或1），表示每个硬币的状态：0――正面向上，和1――反面向上，不允许出现多余空格）
* :running:	**思路：翻n-1枚硬币，就是有一枚不翻，也可以理解为翻一枚，直接上程序说话：**
``` c++
#include<iostream>
using namespace std;
const int maxn=101;
bool a[maxn];//a数组负责存储硬币的状态
int n;//n枚硬币
int main()
{
    cin>>n;
    cout<<n<<endl;//因为相当于只翻一枚，所以翻n次即可
    for(int i=1;i<=n;i++){//i表示这是第几次翻
        for(int j=1;j<=n;j++){//表示当前翻得是第几枚硬币
            if(j!=i){//如果不为第i枚
                if(a[j])a[j]=0;//1变成0
                else a[j]=1;//0变成1
            }
            cout<<a[j];//输出当前状态
        }
        cout<<endl;//别忘了换行
    }
    return 0;
}
```
